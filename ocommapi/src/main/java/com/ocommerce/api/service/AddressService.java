package com.ocommerce.api.service;

import com.ocommerce.api.constants.AddressStatus;
import com.ocommerce.api.exception.AddressNotFoundException;
import com.ocommerce.api.exception.UserNotFoundException;
import com.ocommerce.api.jpa.entities.Address;
import com.ocommerce.api.jpa.repositories.AddressRepository;
import com.ocommerce.api.mapper.AddressMapper;
import com.ocommerce.api.model.AddressDto;
import com.ocommerce.api.model.UserDetails;

import java.util.List;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class AddressService {
    private final AddressRepository addressRepository;
    private final UserService userService;

    public AddressService(AddressRepository addressRepository, UserService userService) {
        this.userService = userService;
        this.addressRepository = addressRepository;
    }

    public AddressDto getDefaultAddressForUser(Long userId) throws AddressNotFoundException {
        Address address = addressRepository.findDefaultAddressByUserId(userId)
                .or(() -> addressRepository.findFirstByUserId(userId))
                .orElseThrow(() -> new AddressNotFoundException("Address not found for user id: " + userId));
        return AddressMapper.toDto(address);
    }

    /**
     * Retrieves an address by user ID and address ID.
     *
     * @param userId    The ID of the user.
     * @param addressId The ID of the address.
     * @return The address if found.
     * @throws AddressNotFoundException if the address is not found for the given
     *                                  user and address IDs.
     */
    public AddressDto getAddressByUserIdAndAddressId(Long userId, Long addressId) throws AddressNotFoundException {
        Address address = addressRepository.findAddressByUserIdAndAddressId(userId, addressId)
                .orElseThrow(() -> new AddressNotFoundException(
                        "Address not found for user id: " + userId + " and address id: " + addressId));
        return AddressMapper.toDto(address);
    }

    /**
     * Retrieves all active addresses for a given user.
     *
     * @param userId The ID of the user.
     * @return A list of active addresses for the user.
     */
    public List<AddressDto> getAllActiveAddressesByUserId(Long userId) {
        return AddressMapper.toDtoList(addressRepository.findAllActiveByUserId(userId));
    }

    @Transactional
    public AddressDto createAddress(AddressDto addressDto, UserDetails user) throws UserNotFoundException {
        if (addressDto.getAddressId() != null) {
            throw new IllegalArgumentException("Address Id will be generated by the database, do not set it manually.");
        }
        Address address = AddressMapper.toEntity(addressDto);
        address.setUser(userService.getUserById(user.getUserId()));
        boolean isDefault = Boolean.TRUE.equals(address.isDefaultAddress());
        Address saved = addressRepository.save(address);
        if (isDefault) {
            addressRepository.unsetDefaultForOtherAddresses(user.getUserId(), saved.getAddressId());
        }
        return AddressMapper.toDto(saved);
    }

    @Transactional
    public AddressDto updateAddress(AddressDto addressDto, UserDetails user)
            throws AddressNotFoundException, UserNotFoundException {
        if (addressDto.getAddressId() == null) {
            throw new AddressNotFoundException("Address not found with id: " + addressDto.getAddressId());
        }
        Address oldAddress = addressRepository.findById(addressDto.getAddressId())
                .orElseThrow(
                        () -> new AddressNotFoundException("Address not found with id: " + addressDto.getAddressId()));
        // Mark old address as terminated and unset default
        oldAddress.setStatus(AddressStatus.TERMINATED);
        oldAddress.setDefaultAddress(false);
        addressRepository.save(oldAddress);

        // Save the new address as a new record
        Address address = AddressMapper.toEntity(addressDto);
        address.setAddressId(null);
        address.setUser(userService.getUserById(user.getUserId()));
        boolean isDefault = Boolean.TRUE.equals(address.isDefaultAddress());
        Address saved = addressRepository.save(address);
        if (isDefault) {
            addressRepository.unsetDefaultForOtherAddresses(user.getUserId(), saved.getAddressId());
        }
        return AddressMapper.toDto(saved);
    }

    /**
     * Deletes an address by user ID and address ID.
     *
     * @param userId    The ID of the user.
     * @param addressId The ID of the address to delete.
     * @throws AddressNotFoundException if the address is not found for the given
     *                                  user and address IDs.
     * @throws UserNotFoundException    if the user is not found.
     */
    @Transactional
    public void deleteAddress(Long userId, Long addressId) throws AddressNotFoundException, UserNotFoundException {
        Address address = addressRepository.findAddressByUserIdAndAddressId(userId, addressId)
                .orElseThrow(() -> new AddressNotFoundException(
                        "Address not found for user id: " + userId + " and address id: " + addressId));
        address.setStatus(AddressStatus.TERMINATED);
        addressRepository.save(address);
    }

    /**
     * Sets the given address as the default address for the user.
     * 
     * @param userId    The ID of the user.
     * @param addressId The ID of the address to set as default.
     * @throws AddressNotFoundException if the address is not found for the given
     *                                  user and address IDs.
     * @throws UserNotFoundException    if the user is not found.
     */
    @Transactional
    public void setDefaultAddress(Long userId, Long addressId) throws AddressNotFoundException, UserNotFoundException {
        Address address = addressRepository.findAddressByUserIdAndAddressId(userId, addressId)
                .orElseThrow(() -> new AddressNotFoundException(
                        "Address not found for user id: " + userId + " and address id: " + addressId));
        addressRepository.unsetDefaultForOtherAddresses(userId, address.getAddressId());
        address.setDefaultAddress(true);
        addressRepository.save(address);
    }

}